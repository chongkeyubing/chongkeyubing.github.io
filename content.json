{"meta":{"title":"李宝刚的博客","subtitle":null,"description":"爱恨随人，来去自由","author":"libaogang","url":"http://libaogang.com"},"pages":[{"title":"关于我","date":"2017-07-28T08:02:35.000Z","updated":"2017-08-02T01:44:52.549Z","comments":true,"path":"about/index.html","permalink":"http://libaogang.com/about/index.html","excerpt":"","text":"我 非前端，非后台，非全栈，什么都做，什么都不会。被动的，沉默的，软弱的，缺少软肋，需要件铠甲。 联系方式 邮箱：237412637@qq.com"},{"title":"gallery","date":"2017-07-29T13:50:33.000Z","updated":"2017-08-02T01:44:52.372Z","comments":true,"path":"gallery/index.html","permalink":"http://libaogang.com/gallery/index.html","excerpt":"","text":""},{"title":"timeline","date":"2017-07-28T08:01:56.000Z","updated":"2017-08-02T01:44:53.007Z","comments":true,"path":"timeline/index.html","permalink":"http://libaogang.com/timeline/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-28T03:09:28.000Z","updated":"2017-08-02T01:44:52.966Z","comments":true,"path":"tags/index.html","permalink":"http://libaogang.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"pjax简要分析","slug":"pjax","date":"2017-07-30T05:12:00.000Z","updated":"2017-08-02T01:44:53.201Z","comments":true,"path":"2017/07/30/pjax/","link":"","permalink":"http://libaogang.com/2017/07/30/pjax/","excerpt":"","text":"在寻找博客程序的过程中了解到了pjax技术，本文简要介绍了pjax技术。遗憾的是，由于本博客架构设计，不能以很小的代价切换到pjax技术。可以移步该博客体验下丝滑般的站内页面跳转。 可以观察到github，facebook都支持这样的一种浏览方式， 当你点击一个站内的链接的时候， 不是做页面跳转， 而是只是站内页面刷新。 浏览器地址栏位上面的地址也会更改， 用浏览器的回退功能也能够回退到上一个页面。这样的用户体验， 比起整个页面都闪一下来说好很多。通过观察请求可以发现，他们都用到了pjax技术。 history新接口 pjax技术使用到了html5中history对象的新方法，简要介绍如下： pushState(state,title,url)方法 向history对象中添加URL。pushState()有三个参数:state对象是一个JSON对象（对应URL，唯一性),它关系到由pushState()方法创建出来的新的history实体；title(现在是被忽略，未作处理)；URL(请求的链接)。利用该方法改变url而不会触发页面的刷新。 replaceState(state,title,url)方法 -history.replaceState() 替换当前的URL而不产生历史记录，参数和pushState一样。 popstate事件 当history实体被改变时，popstate事件将会发生。如果history实体是有pushState和replaceState方法产生的popstate事件的state属性会包含一份来自history实体的state对象的拷贝。 传统ajax虽然传统ajax可以异步获取服务端数据并无刷新改变页面内容，但是无法改变浏览器url。因此有种方案是在内容发生改变后通过改变URL的hash的方式获得更好的可访问性（因为只有改变url的hash才不会触发页面刷新），但是这种方案有时候不能很好的处理浏览器的前进和后退。pjax的出现就是为了解决这些问题。 pjaxpjax就是pushState和ajax的结合，不需要重新加载整个页面就能从服务器加载Html到你当前页面，这个ajax请求会有永久链接、title并支持浏览器的回退/前进按钮。 优点 减轻服务端压力按需请求，每次只需加载页面的部分内容，而不用重复加载一些公共的资源文件和不变的页面结构，大大减小了数据请求量，以减轻对服务器的带宽和性能压力，还大大提升了页面的加载速度。 优化页面跳转体验常规页面跳转需要重新加载画面上的内容，会有明显的闪烁，而且往往和跳转前的页面没有连贯性，用户体验不是很好。如果再遇上页面比较庞大、网速又不是很好的情况，用户体验就更加雪上加霜了。使用pjax后，由于只刷新部分页面，切换效果更加流畅，而且可以定制过度动画，在等待页面加载的时候体验就比较舒服了。 缺点 使服务端处理变得复杂要做到普通请求返回完整页面，而pjax请求只返回部分页面，服务端就需要做一些特殊处理，当然这对于设计良好的后端框架来说，添加一些统一处理还是比较容易的，自然也没太大问题。另外，即使后台不做处理，设置pjax的fragment参数来达到同样的效果。 简易原理观察github的请求,当点击Issues标签时，浏览器发送了一个ajax请求，拉取了部分html片段，同时浏览器url及标题也发生变化。 以下代码实现了一个简易pjax以帮助理解pjax原理 $(document).ready(function() { $('#main').on('click','a',function(e) { if(window.history.pushState) { e.preventDefault(); //拦截链接跳转 url = $(this).attr('href'); $.ajax({ async: true, type: 'GET', url: 'data.php', data: 'pjax=1', success: function(data) { window.history.pushState(null, null, url); //改变URL和添加返回历史 document.title = data.title; //设置标题 $('#main').html(data.main); //更换页面main部分内容 } }); } else { return; //低版本IE8等不支持HTML5 pushState,直接返回进行链接跳转 } }); }); 项目地址pjax源码及具体的插件使用方式见jquery-pjax项目","categories":[{"name":"技术","slug":"技术","permalink":"http://libaogang.com/categories/技术/"}],"tags":[{"name":"pjax","slug":"pjax","permalink":"http://libaogang.com/tags/pjax/"},{"name":"ajax","slug":"ajax","permalink":"http://libaogang.com/tags/ajax/"}]},{"title":"记一次web安全漏洞分析与处理","slug":"web-security","date":"2017-07-29T06:31:00.000Z","updated":"2017-08-02T01:44:53.156Z","comments":true,"path":"2017/07/29/web-security/","link":"","permalink":"http://libaogang.com/2017/07/29/web-security/","excerpt":"","text":"记一次用Appsan扫描站点扫描出的漏洞与解决方案 HTTP PUT方法站点篡改原理分析通过HTTP PUT 或者DELETE方法，可能会在 Web 服务器上上载、修改或删除 Web 页面、脚本和文件，这通常意味着完全破坏服务器及其内容。 解决方案 方案一 修改DefaultServlet初始化参数readonly为true，对web服务器上的文件访问权限会变为只读，因此如PUT 和 DELETE的HTTP命令将被拒绝执行。 &lt;servlet> &lt;servlet-name>default&lt;/servlet-name> &lt;servlet-class>org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class> &lt;init-param> &lt;param-name>debug&lt;/param-name> &lt;param-value>0&lt;/param-value> &lt;/init-param> &lt;init-param> &lt;param-name>listings&lt;/param-name> &lt;param-value>false&lt;/param-value> &lt;/init-param> &lt;init-param> &lt;param-name>readonly&lt;/param-name> &lt;param-value>true&lt;/param-value> &lt;/init-param> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> 方案二 在web.xml中加入以下配置，禁止PUT DELETE HEAD OPTIONS TRACE方法 &lt;security-constraint> &lt;web-resource-collection> &lt;url-pattern>/*&lt;/url-pattern> &lt;http-method>PUT&lt;/http-method> &lt;http-method>DELETE&lt;/http-method> &lt;http-method>HEAD&lt;/http-method> &lt;http-method>OPTIONS&lt;/http-method> &lt;http-method>TRACE&lt;/http-method> &lt;/web-resource-collection> &lt;auth-constraint>&lt;/auth-constraint> &lt;/security-constraint> 跨站脚本攻击(Cross Site Scripting)xss是一门热门又不太受重视的Web攻击手法，因为这是一种被动的攻击方式，耗时长，有一定几率不成功，且没有相应的软件来完成自动化攻击。但是这并不影响黑客对此攻击手法的偏爱，因为几乎每个网站都存在xss漏洞。 原理分析本地搭建一个java web环境，新建xss.jsp文件，代码如下 &lt;!DOCTYPE> &lt;html> &lt;head> &lt;title>xss&lt;/title> &lt;/head> &lt;body> &lt;form action=\"\" method=\"get\"> &lt;input type=\"text\" name=\"xss\"> &lt;input type=\"submit\"> &lt;/form> &lt;hr> your input is: &lt;%=request.getParameter(\"xss\")%> &lt;/body> &lt;/html> 页面是这样我们输入123，结果是这样的，没有任何问题看源代码，我们输入的字符串被原封不动地输出了 &lt;!DOCTYPE> &lt;html> &lt;head> &lt;title>xss&lt;/title> &lt;/head> &lt;body> &lt;form action=\"\" method=\"get\"> &lt;input type=\"text\" name=\"xss\"> &lt;input type=\"submit\"> &lt;/form> &lt;hr> your input is: 123 &lt;/body> &lt;/html> 如果我们输入这段代码会怎么样？ &lt;script>alert(\"css\")&lt;/script> 因为页面会原封不动输出我们的输入，预期的页面的源代码应该是这样的 &lt;!DOCTYPE> &lt;html> &lt;head> &lt;title>xss&lt;/title> &lt;/head> &lt;body> &lt;form action=\"\" method=\"get\"> &lt;input type=\"text\" name=\"xss\"> &lt;input type=\"submit\"> &lt;/form> &lt;hr> your input is: &lt;script>alert(\"css\")&lt;/script> &lt;/body> &lt;/html> 我们的脚本会被执行，即弹窗，而事实也确实是这样的，成功弹窗。 这时候已经可以确定存在xss漏洞了。其实到这里我也有点疑惑，弹个窗能有多大危害？其实弹窗只是测试，只要确定存在xss漏洞，那么就可以利用这个漏洞来插入并执行我们准备好的脚本，获取cookie从而获取用户权限，操纵用户行为。 当然，这只是基本原理。xss攻击方式多种多样，这里不作一一探索。 解决方案新建XssHttpServletRequestWrapper类，继承自HttpServletRequestWrapper，并覆盖以下方法，将危险字符转义或去除。 import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper { public XssHttpServletRequestWrapper(HttpServletRequest servletRequest) { super(servletRequest); } @Override public String[] getParameterValues(String parameter) { String[] values = super.getParameterValues(parameter); if (values==null){ return null; } int count = values.length; String[] encodedValues = new String[count]; for (int i = 0; i &lt; count; i++) { encodedValues[i] = cleanXSS(values[i]); } return encodedValues; } @Override public String getParameter(String parameter) { String value = super.getParameter(parameter); if (value == null) { return null; } return cleanXSS(value); } @Override public String getHeader(String name) { String value = super.getHeader(name); if (value == null) return null; return cleanXSS(value); } private String cleanXSS(String value) { //You'll need to remove the spaces from the html entities below value = value.replaceAll(\"&lt;\", \"&lt;\").replaceAll(\">\", \">\"); value = value.replaceAll(\"\\\\(\", \"(\").replaceAll(\"\\\\)\", \")\"); value = value.replaceAll(\"'\", \"'\"); value = value.replaceAll(\"eval\\\\((.*)\\\\)\", \"\"); value = value.replaceAll(\"[\\\\\\\"\\\\\\'][\\\\s]*javascript:(.*)[\\\\\\\"\\\\\\']\", \"\\\"\\\"\"); value = value.replaceAll(\"script\", \"\"); return value; } } 新建XSSFilter类 import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletRequest; public class XSSFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"enter xssfilter----------------\"); XssHttpServletRequestWrapper xssRequest = new XssHttpServletRequestWrapper( (HttpServletRequest) request); chain.doFilter(xssRequest, response); } @Override public void destroy() { } } web.xml配置如下，拦截所有请求。 &lt;filter> &lt;filter-name>XSSFilter&lt;/filter-name> &lt;filter-class>xxx.xxx.XSSFilter&lt;/filter-class> &lt;/filter> &lt;filter-mapping> &lt;filter-name>XSSFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> 跨站请求伪造 (Cross Site Request Forgery)如果说xss的本质是攻击者获取了用户身份进行恶意操作，而csrf的本质是借用用户身份进行而已恶意操作。 原理分析看下面一个例子：A在银行有一笔存款，可以通过请求 http://www.bank.com/transfer?account=A&amp;amount=1000000&amp;for=B 把钱转到B的账户下。C在该银行也有账户，于是他伪造了一个地址 http://www.bank.com/transfer?account=A&amp;amount=1000000&amp;for=C 。如果直接访问，服务器会根据客户端cookie和服务端session识别出当前登录用户是C而不是A，不能接受请求。于是C新建一个广告页面，将此链接伪造在广告下，诱使A自己点这个链接。如果A在这个广告页点了这个链接，那么就会在他不知情的情况下将存款转给了C。 为什么会这样？因为受害者首先已经登录了银行网站取得了合法身份。在浏览器进程的生命周期内，即使浏览器同一个窗口打开了新的tab页面，cookie也都是有效的，在浏览器同一个窗口的多个tab页面里面是共享的。所以当A在广告页点击了C伪造的请求时，同时也携带了A在银行tab页的合法身份。而此时恰好服务端session还没有过期，于是服务器成功响应请求。 可以看到，以上例子是一个get请求，其实无论是get、post请求，链接、表单、ajax请求都无法避免跨站请求伪造的问题。 解决方案 方案一 通过referer 判定来源页面 String referer=httpRequest.getHeader(\"referer\"); if (referer!= null &amp;&amp; !referer.startsWith(\"http://www.bank.com\") { return; } 从以上例子可以看出，A在点击伪造的请求时肯定是不在http://www.bank.com 页面的，因此可以通过判断来源页面来拦截伪造的请求。但是referer是存在于http请求头部的， 可以拦截请求并任意修改referer值。虽然这个例子中受害者不可能自己去修改referer，但终究还是可能存在安全隐患。 方案二 令牌同步 Synchronizer token pattern 令牌同步模式（Synchronizer token pattern，简称STP）是在用户请求的页面中的所有表单中嵌入一个token，在服务端验证这个token的技术。token可以是任意的内容，但是一定要保证无法被攻击者猜测到或者查询到。攻击者在请求中无法使用正确的token，因此可以判断出未授权的请求。 Cookie-to-Header Token 对于使用Js作为主要交互技术的网站，将CSRF的token写入到cookie中 Set-Cookie: CSRF-token=i8XNjC4b8KVok4uw5RftR38Wgp2BFwql; expires=Thu, 23-Jul-2015 10:25:33 GMT; Max-Age=31449600; Path=/ 然后使用javascript读取token的值，在发送http请求的时候将其作为请求的header X-CSRF-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql 最后服务器验证请求头中的token是否合法。","categories":[{"name":"技术","slug":"技术","permalink":"http://libaogang.com/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://libaogang.com/tags/web/"},{"name":"安全","slug":"安全","permalink":"http://libaogang.com/tags/安全/"}]},{"title":"call by sharing","slug":"call-by-sharing","date":"2017-07-28T11:50:00.000Z","updated":"2017-08-02T01:44:53.128Z","comments":true,"path":"2017/07/28/call-by-sharing/","link":"","permalink":"http://libaogang.com/2017/07/28/call-by-sharing/","excerpt":"","text":"在了解到call by sharing这种函数参数传递机制之前，误以为javascript函数参数传递机制采用的是call by value （值传递）和call by reference（引用传递）。本文将分析下call by sharing这种参数传递机制。 数据类型及内存分配javascript中的数据类型： 原始据类型primitive type ，比如Undefined,Null,Boolean,Number，String 引用类型 Object type ，比如Object,Array,Function,Date 不同数据类型的内存分配： 原始类型：存储在栈中的简单数据段。因为原始数据类型占据的内存空间是固定的，所以它们的值是直接存储在变量访问的位置即栈中，便于迅速查找变量的值。 引用类型：存储在堆中的对象。引用数据类型大小经常发生变化，如果把引用类型的值直接放在栈中会降低变量查找的速度。所以存放变量的栈空间的值是该对象存储在堆内存中的地址。因为内存地址的大小是固定的，所以把它存储在栈中对变量的查找性能无任何负面影响。 值传递（call by value）vs引用传递（call by reference）按值传递(call by value)是最常用的求值策略：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。 按引用传递(call by reference)时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。 按值传递由于每次都需要克隆副本，对一些复杂类型，性能较低。两种传值方式都有各自的问题。按引用传递会使函数调用的追踪更加困难，有时也会引起一些微妙的BUG。 以下为c的一个例子解释值传递和引用传递 void Modify(int p, int * q){ p = 27; // 按值传递 - p是实参a的副本, 只有p被修改 *q = 27; // q是b的引用，q和b都被修改 } int main() { int a = 1; int b = 1; Modify(a, &amp;b); // a 按值传递, b 按引用传递, // a 未变化, b 改变了 return(0); } 探寻javascript函数参数传值方式以下代码可以看出js中基本类型是按值传递的 var a = 1; function foo(x) { x = 2; } foo(a); console.log(a); // 仍为1, 未受x = 2赋值所影响 再看以下代码，obj的属性被修改了，说明obj和o指向同一个对象，那这是否就能说明js中的引用类型就是按引用传递的呢？ var obj = {x : 1}; function foo(o) { o.x = 2; } foo(obj); console.log(obj.x); // 2 以下代码，如果是按引用传递，obj的值应该被修改为libaogang才对，但是事实并非如此，所以js中的引用类型并不是按引用传递。 var obj = {x : 1}; function foo(o) { o = \"libaogang\"; } foo(obj); console.log(obj.x); // 仍然是1, obj并未被修改为libaogang 共享传递（call by sharing）准确的说，JS中的基本类型按值传递，对象类型按共享传递的(call by sharing，也叫按对象传递、按对象共享传递)。最早由Barbara Liskov. 在1974年的GLU语言中提出。值得注意的是，Python、Java、Ruby等多种语言都采用此种求值策略。 该求值策略表现为：形参为实参引用的副本，通过形参可以改变实参对象的属性，但是改变形参本身不会影响实参。看以下代码 var obj1 = { value:'1' }; var obj2 = { value:'2' }; function changeStuff(obj){ obj.value = '3'; obj = obj2; } console.log(obj1.value); //'3' 当调用changeStuff（obj），形参obj为实参obj1的副本。即形参obj中存放的是obj1对象在堆中的内存地址，所以通过形参obj可以改变obj1对象的属性。而当改变形参obj的值时，并不会影响实参obj1的值。所以当执行obj=obj2时，obj1.value仍为3。 结论综上，js的基本类型是按值传递，引用类型是按共享传递。而按共享传递本质就是对象在堆内存中的地址的按值传递，所以也可以认为js中所有函数的参数都按值传递的。","categories":[{"name":"技术","slug":"技术","permalink":"http://libaogang.com/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://libaogang.com/tags/javascript/"},{"name":"java","slug":"java","permalink":"http://libaogang.com/tags/java/"},{"name":"函数","slug":"函数","permalink":"http://libaogang.com/tags/函数/"}]}]}